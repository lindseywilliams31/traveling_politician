# TRAVELING POLITICIAN
# Lindsey Williams



#importing dataframe of all cities/zipcodes/coordinates

import pandas as pand
df_allcities = pand.read_csv("zip_codes.csv")


#classes and modules

import itertools

class Point:
    """ Point class represents and manipulates x,y coords. """

    def __init__(self, x=0, y=0):
        """ Create a new point at x, y """
        self.x = x
        self.y = y


class State:
    """ Point class represents a state and holds a point(coordinates) """

    def __init__(self, state, point):
        """ Create a new point at x, y """
        self.abbrev = abbrev
        self.point = point


#V.0

def distance(point1, point2):
    """
    A function that takes 2 points and calculates the straight
    line difference between them

    Precondition: point1 and point2 must be point class with both with
    floats for x and y
    """
    sqd_value = ((point1.x-point2.x)^2)+((point1.x-point2.x)^2)
    value = sqd_value^(1/2)
    return value

#V.1

iowa_cord = Point(5,6)
iowa = State("IA", iowa_cord)
d_c_cord = Point(5,6)
d_c = State("DC", d_c_cord)


def distance_start_to_end(list):
    """
    A function that calculates the distance of this order of stops

    Precondition: list must be a list of States
    """
    dist = 0
    for a in (len(list)-1):
        point1=(list[a]).point
        point2=(list[a+1]).point
        distance = distance(point1, point2)
        dist += distance
    return dist

#V.2

def every_order(lst):
    """
    A function that returns a list of lists of the different orders of states

    Precondition: list must be a list of States (-IA and -DC)
    """

    # If there is only one element in lst then, only
    # one permuatation is possible
    if len(lst) == 1:
        lst.insert(iowa,0)
        lst.append(d_c)
        return lst

    # Find the permutations for lst if there are
    # more than 1 characters

    l = [] # empty list that will store current permutation

    # Iterate the input(lst) and calculate the permutation
    for i in range(len(lst)):
       m = lst[i]

       # Extract lst[i] or m from the list.  remLst is
       # remaining list
       remLst = lst[:i] + lst[i+1:]

       # Generating all permutations where m is first
       # element
       for p in permutation(remLst):
           l.append([m] + p)
    for a in l:
        a.insert(iowa,0)
        a.append(d_c)
    return l


def making_dict(l):
    """
    A function that returns a dictionary of lists of all orders and distance it takes

    Precondition: list must be a list of lists of States
    """
    dictionary={}
    for order in l:
        distance=distance_start_to_end(order)
        stg=""
            for ste in len(order):
                if ste == order[-1]:
                    stg=stg+(ste.abbrev)
                else:
                    stg=stg+(ste.abbrev)+":"
                dictionary[stg]=distance
    return dictionary


def choose_shortest(dictt):
    """
    A function that makes a dicitonary with the single key and lowest value

    Precondition: dictt is a dicitonary with at least on entry
    """

    if len(dictt) == 1:
        return dictt
    else:
        min_key = min(dictt, key=dictt.get)
        valuee = dictt[min_key]
        new_dict = {min_key: valuee}
        return new_dict

def all_together(lst):
    """
    A function that takes a list of state objects and spits out the order and
    distance in a dictionary to go that is the shortest path

    Precondition: list is empty or only conists of state objects
    """
    return choose_shortest(making_dict(every_order(lst)))
